## javaScript2面向对象和原型

## 面向对象

> 面向对象的三大特性
>
> > 继承  封装  多态
> >
> > > 封装
> > >
> > > > 把一些变量和方法封装到对象中
> > > > 把一些相应模块放到对象中，**使结构变清晰**
> > >
> > > 继承
> > >
> > > > 一个对象没有一些方法和属性，把另一个对象
> > > > 的属性和方法拿过来使用
> > >
> > > 多态
> > >
> > > > js多态没有体现   多态是在强类型语言中比较常用
> > > > 使用父类的引用（指针）指向子类的对象  就叫做多态
> > > > 使用多态来隐藏不同
> > > > 父类的属性和方法供子类使用，但父类不能
> > > > 访问子类属性和方法
>
> 创建对象的方式
>
> > 1. 对象字面量
> >
> >    只能创建一次对象，复用性差，创建多个对象
> >    代码冗余度太高
> >
> > 2. 内置构造函数
> >
> >    ```javascript
> >    var obj1 = new object()
> >    ```
> >
> > 3. 封装简单的工厂函数
> >
> >    ```javascript
> >    function createObj(){
> >              var obj = {};
> >              obj.xx=xxx;
> >              return obj;
> >         }
> >    
> >    
> >    ```
> >
> >    
> >
> > 4. 自定义构造函数
> >
> >    > 创建
> >    >
> >    > > 构造函数是用来初始化对象的  和new关键字同时出现
> >    > > 构造函数名，首字母要大写以示区分
> >    > > 默认隐含的操作，把刚才用new新创建出来的  对象赋值给this
> >    >
> >    > 返回过程
> >    >
> >    > > 使用new关键字来创建对象
> >    > > 调用构造函数，把新创建出来的对象赋值给构造函数内的this
> >    > > 在构造函数内使用this为新创建出来的对象
> >    > > 新增成员
> >    > > 默认返回新创建的这个对象
> >    > > (普通的函数，如果不写返回语句，会返回undefined)
> >    >
> >    > 构造函数返回值
> >    >
> >    > > 默认返回新创建出来的对象
> >    > > 如果自己写return语句 return的是（return ;）空值或者基本类型值
> >    > > （或者null）都默认返回新创建的对象
> >    > > 如果返回的是object，将不返回新创建对象  返回return 后边的值
> >
> > 一些忽略知识
> >
> > > bark（）（加括号是调用，变成返回值）  不传参会变成undefined
> > > new 可以新开辟出一段内存
> > >  this 谁调用就是谁
> > >
>
> 调用对象
>
> > js提供了方法来调用其他对象的方法  call apply 以及（bind()es5）
> >
> > ```javascript
> > var typeStr=Object.prototype.toString.call(arr)
> > typeStr = typeStr.slice(8,-1)
> > //判断什么函数类型，实现深度克隆时用
> > ```
> >
> > ### 注意
> >
> > > 如果使用正常的函数一样使用构造函数 构造函数中的this将不再指向新创建对象，指
> > > 向window全局对象
> > > 给对象添加成员全部都添加给window
> > >
> > > 如果构造函数没有传参，小括号可以省略
> > > var stu = new Student;

## 原型（超级重要）

> 概念
>
> > prototype是构造函数的属性，和对象没关系
> >
> > 在构造函数创建出来时，系统会默认的帮构造函数创建并关联一个神秘对象，这个对象就是原型。
>
> 作用
>
> > 原型中的属性和方法 可以被使用
> > 该构造函数创建出来的对象使用原型默认是一个空对象
>
> 访问
>
> > 构造函数.prototype
> >
> > 当使用对象去访问属性和方法的时候,会首先在对象自己内部进行查找，
> > 如果找到了，就直接使用,如果没有找到，就去原型中查找，查找到之后使用
> > 如果原型中还没有， 如果是属性，就是Undefined
> > 如果是方法，就报错
> >
> > **构造函数的原型对象中的成员，可以被该构造函数创建出来的所有对象访问**
> >
> >  实例化
> >
> > > 通过构造函数创建对象的过程就是实例化
> >
> > 实例
> >
> > > 通过构造函数实例化出来的对象,就是该构造函数的一个实例
>
> 使用方法
>
> > + 利用对象的动态特性给原型对象添加
> > + 直接替换对象
> >
> > **注意**
> >
> > 如果使用第二种方式使用原型，那么会出现如下问题：
> > 在替换原型之前创建的对象的原型 和 
> > 在替换原型对象之后的创建的对象
> > 的原型 不是同一个！
> >
> >  
>
> 注意事项
>
> > 使用对象访问属性的时候，如果在本身内找不到就会去原型中查找
> > 但是使用点语法进行属性赋值的时候，并不会去原型中进行查找
> > 使用点语法赋值的时候如果，对象中不存在该属性，就会给该对象新增该属性，而不会去修改原型中的属性
>
> 访问（补充）
>
> > 通过构造函数访问原型
> >
> > > Person.prototype
> >
> > 通过对象访问原型
> >
> > > __proto__属性
> > >
> > > __proto__是一个非标准的属性,为了保证通用性 这个属性不推荐使用
> > >
> > > 用途
> > >
> > > > 主要用来做调试
>
> 注意
>
> > 在使用新的对象替换掉默认的原型对象之后,原型对象中的constructor属性会变成 Object
> > 为了保证整个  构造函数---原型----对象 之间的关系的合理性
> > 应做如下操作：
> >
> > + 在替换原型对象的时候，
> > + 在新的原型对象中手动添加 constructor 属性